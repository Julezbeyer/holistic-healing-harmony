plugin:vite:react-swc] × the name `useState` is defined multiple times
     ╭─[/home/runner/workspace/src/pages/Booking.tsx:1:1]
   1 │ import { useState, useEffect } from 'react';
     ·          ────┬───
     ·              ╰── previous definition of `useState` here
   2 │ import { DatePicker } from '@/components/booking/DatePicker';
   3 │ import { TimeSlotPicker } from '@/components/booking/TimeSlotPicker';
   4 │ import { BookingForm } from '@/components/booking/BookingForm';
   5 │ import { BookingConfirmation } from '@/components/booking/BookingConfirmation';
   6 │ import { Appointment, TimeSlot, BookingFormData } from '@/lib/types';
   7 │ import { generateTimeSlots } from '@/lib/date-utils';
   8 │ import { v4 as uuidv4 } from 'uuid';
   9 │ import { supabase } from '@/integrations/supabase/client';
  10 │ import { toast } from 'sonner';
  11 │ 
  12 │ enum BookingStep {
  13 │   SELECT_DATE,
  14 │   SELECT_TIME,
  15 │   FILL_FORM,
  16 │   CONFIRMATION
  17 │ }
  18 │ 
  19 │ export default function Booking() {
  20 │   const [currentStep, setCurrentStep] = useState<BookingStep>(BookingStep.SELECT_DATE);
  21 │   const [selectedDate, setSelectedDate] = useState<Date | undefined>(undefined);
  22 │   const [timeSlots, setTimeSlots] = useState<TimeSlot[]>([]);
  23 │   const [selectedTimeSlot, setSelectedTimeSlot] = useState<TimeSlot | null>(null);
  24 │   const [appointment, setAppointment] = useState<Appointment | null>(null);
  25 │   const [isSubmitting, setIsSubmitting] = useState(false);
  26 │   const [isLoading, setIsLoading] = useState(false);
  27 │   const [bookingResult, setBookingResult] = useState<{ success: boolean; appointment: any | null }>({ success: false, appointment: null });
  28 │ 
  29 │ 
  30 │   // Fetch time slots for the selected date
  31 │   useEffect(() => {
  32 │     if (!selectedDate) return;
  33 │ 
  34 │     const fetchTimeSlots = async () => {
  35 │       setIsLoading(true);
  36 │ 
  37 │       try {
  38 │         // Formatiere das Datum für Supabase (YYYY-MM-DD)
  39 │         const formattedDate = selectedDate.toISOString().split('T')[0];
  40 │ 
  41 │         // Prüfe, ob bereits Zeitfenster für diesen Tag existieren
  42 │         const { data: existingSlots, error: fetchError } = await supabase
  43 │           .from('time_slots')
  44 │           .select('*')
  45 │           .eq('date', formattedDate);
  46 │ 
  47 │         if (fetchError) throw fetchError;
  48 │ 
  49 │         // Wenn Zeitfenster existieren, verwende diese
  50 │         if (existingSlots && existingSlots.length > 0) {
  51 │           const mappedSlots = existingSlots.map(slot => ({
  52 │             id: slot.id,
  53 │             date: slot.date,
  54 │             startTime: slot.start_time,
  55 │             endTime: slot.end_time,
  56 │             isAvailable: !slot.is_booked
  57 │           }));
  58 │ 
  59 │           setTimeSlots(mappedSlots);
  60 │         } else {
  61 │           // Generiere neue Zeitfenster und speichere sie in Supabase
  62 │           const generatedSlots = generateTimeSlots(selectedDate);
  63 │ 
  64 │           // Speichere die Slots in Supabase
  65 │           const { data: savedSlots, error: insertError } = await supabase
  66 │             .from('time_slots')
  67 │             .insert(
  68 │               generatedSlots.map(slot => ({
  69 │                 date: formattedDate,
  70 │                 start_time: slot.startTime,
  71 │                 end_time: slot.endTime,
  72 │                 is_booked: false
  73 │               }))
  74 │             )
  75 │             .select();
  76 │ 
  77 │           if (insertError) throw insertError;
  78 │ 
  79 │           if (savedSlots) {
  80 │             // Mappe die gespeicherten Slots zum Frontend-Format
  81 │             const mappedSlots = savedSlots.map(slot => ({
  82 │               id: slot.id,
  83 │               date: slot.date,
  84 │               startTime: slot.start_time,
  85 │               endTime: slot.end_time,
  86 │               isAvailable: !slot.is_booked
  87 │             }));
  88 │ 
  89 │             setTimeSlots(mappedSlots);
  90 │           }
  91 │         }
  92 │ 
  93 │         setCurrentStep(BookingStep.SELECT_TIME);
  94 │       } catch (error) {
  95 │         console.error('Error fetching/creating time slots:', error);
  96 │         toast.error('Fehler beim Laden der Verfügbarkeiten');
  97 │       } finally {
  98 │         setIsLoading(false);
  99 │       }
 100 │     };
 101 │ 
 102 │     fetchTimeSlots();
 103 │   }, [selectedDate]);
 104 │ 
 105 │   const handleDateSelect = (date: Date | undefined) => {
 106 │     setSelectedDate(date);
 107 │   };
 108 │ 
 109 │   const handleTimeSlotSelect = (timeSlot: TimeSlot) => {
 110 │     setSelectedTimeSlot(timeSlot);
 111 │     setCurrentStep(BookingStep.FILL_FORM);
 112 │   };
 113 │ 
 114 │   const handleFormSubmit = async (formData: BookingFormData) => {
 115 │     setIsSubmitting(true);
 116 │ 
 117 │     try {
 118 │       console.log('Submitting booking with time slot ID:', selectedTimeSlot?.id);
 119 │ 
 120 │       if (!selectedTimeSlot?.id) {
 121 │         throw new Error('Kein Zeitfenster ausgewählt');
 122 │       }
 123 │ 
 124 │       // Prüfen, ob der Zeitslot tatsächlich existiert
 125 │       const { data: slotExists, error: slotCheckError } = await supabase
 126 │         .from('time_slots')
 127 │         .select('id')
 128 │         .eq('id', selectedTimeSlot.id)
 129 │         .single();
 130 │ 
 131 │       if (slotCheckError || !slotExists) {
 132 │         console.error('Time slot check error:', slotCheckError);
 133 │         throw new Error(`Das gewählte Zeitfenster existiert nicht in der Datenbank: ${JSON.stringify(slotCheckError || 'No data')}`);
 134 │       }
 135 │ 
 136 │       // Create appointment record in Supabase
 137 │       const { data, error } = await supabase
 138 │         .from('appointments')
 139 │         .insert({
 140 │           time_slot_id: selectedTimeSlot.id,
 141 │           name: formData.name,
 142 │           email: formData.email,
 143 │           phone: formData.phone,
 144 │           notes: formData.notes || null,  // Explizit null setzen wenn leer
 145 │         })
 146 │         .select()
 147 │         .single();
 148 │ 
 149 │       if (error) {
 150 │         console.error('Appointment creation error:', error);
 151 │         throw new Error(`Error creating appointment: ${JSON.stringify(error)}`);
 152 │       }
 153 │ 
 154 │       // Update time slot to mark as booked
 155 │       const { error: updateError } = await supabase
 156 │         .from('time_slots')
 157 │         .update({ is_booked: true })
 158 │         .eq('id', selectedTimeSlot.id);
 159 │ 
 160 │       if (updateError) {
 161 │         console.error('Time slot update error:', updateError);
 162 │         throw new Error(`Error updating time slot: ${JSON.stringify(updateError)}`);
 163 │       }
 164 │ 
 165 │       // E-Mail-Bestätigung senden
 166 │       try {
 167 │         import('@/lib/email-utils').then(({ sendConfirmationEmail }) => {
 168 │           sendConfirmationEmail(data[0], selectedTimeSlot).then(() => {
 169 │             console.log('Bestätigungs-E-Mail gesendet');
 170 │           }).catch((emailError) => {
 171 │             console.error('Fehler beim Senden der Bestätigungs-E-Mail:', emailError);
 172 │             // Buchung wird trotzdem fortgesetzt, auch wenn E-Mail fehlschlägt
 173 │           });
 174 │         });
 175 │       } catch (emailError) {
 176 │         console.error('Fehler beim Senden der Bestätigungs-E-Mail:', emailError);
 177 │         // Buchung wird trotzdem fortgesetzt, auch wenn E-Mail fehlschlägt
 178 │       }
 179 │ 
 180 │       setBookingResult({
 181 │         success: true,
 182 │         appointment: data,
 183 │       });
 184 │ 
 185 │       setCurrentStep(BookingStep.CONFIRMATION);
 186 │     } catch (error: any) {
 187 │       console.error('Error creating appointment:', error);
 188 │       toast.error('Fehler bei der Terminbuchung: ' + (error.message || 'Unbekannter Fehler'));
 189 │     } finally {
 190 │       setIsLoading(false);
 191 │     }
 192 │   };
 193 │ 
 194 │   const resetBooking = () => {
 195 │     setCurrentStep(BookingStep.SELECT_DATE);
 196 │     setSelectedDate(undefined);
 197 │     setTimeSlots([]);
 198 │     setSelectedTimeSlot(null);
 199 │     setAppointment(null);
 200 │     setIsSubmitting(false);
 201 │     setIsLoading(false);
 202 │     setBookingResult({ success: false, appointment: null });
 203 │   };
 204 │ 
 205 │   return (
 206 │     <div className="container mx-auto px-4 py-12">
 207 │       <div className="max-w-3xl mx-auto">
 208 │         <div className="text-center mb-10">
 209 │           <h1 className="text-3xl font-bold mb-4">Termin buchen</h1>
 210 │           <p className="text-muted-foreground">
 211 │             Wählen Sie einen passenden Termin für Ihre persönliche Beratung oder Therapie.
 212 │           </p>
 213 │         </div>
 214 │ 
 215 │         <div className="mb-8">
 216 │           <div className="flex justify-between items-center mb-6">
 217 │             <div className="flex space-x-2">
 218 │               {[...Array(3)].map((_, i) => (
 219 │                 <div
 220 │                   key={i}
 221 │                   className={`w-8 h-8 rounded-full flex items-center justify-center ${
 222 │                     i < currentStep ? 'bg-primary text-primary-foreground' : 
 223 │                     i === currentStep ? 'bg-primary/20 text-primary border border-primary' : 
 224 │                     'bg-muted text-muted-foreground'
 225 │                   }`}
 226 │                 >
 227 │                   {i + 1}
 228 │                 </div>
 229 │               ))}
 230 │             </div>
 231 │ 
 232 │             <span className="text-sm text-muted-foreground">
 233 │               Schritt {currentStep + 1} von {Object.keys(BookingStep).length / 2}
 234 │             </span>
 235 │           </div>
 236 │         </div>
 237 │ 
 238 │         {currentStep === BookingStep.SELECT_DATE && (
 239 │           <DatePicker onDateSelect={handleDateSelect} />
 240 │         )}
 241 │ 
 242 │         {currentStep === BookingStep.SELECT_TIME && (
 243 │           <>
 244 │             <button
 245 │               onClick={() => setCurrentStep(BookingStep.SELECT_DATE)}
 246 │               className="mb-4 text-sm text-primary flex items-center"
 247 │             >
 248 │               ← Zurück zur Datumsauswahl
 249 │             </button>
 250 │ 
 251 │             {isLoading ? (
 252 │               <div className="text-center py-8">Lade Verfügbarkeiten...</div>
 253 │             ) : (
 254 │               <TimeSlotPicker 
 255 │                 timeSlots={timeSlots} 
 256 │                 onTimeSlotSelect={handleTimeSlotSelect} 
 257 │               />
 258 │             )}
 259 │           </>
 260 │         )}
 261 │ 
 262 │         {currentStep === BookingStep.FILL_FORM && selectedTimeSlot && (
 263 │           <>
 264 │             <button
 265 │               onClick={() => setCurrentStep(BookingStep.SELECT_TIME)}
 266 │               className="mb-4 text-sm text-primary flex items-center"
 267 │             >
 268 │               ← Zurück zur Zeitauswahl
 269 │             </button>
 270 │ 
 271 │             <BookingForm 
 272 │               selectedTimeSlot={selectedTimeSlot}
 273 │               onSubmit={handleFormSubmit}
 274 │               isSubmitting={isSubmitting}
 275 │             />
 276 │           </>
 277 │         )}
 278 │ 
 279 │         {currentStep === BookingStep.CONFIRMATION && bookingResult.success && bookingResult.appointment && selectedTimeSlot && (
 280 │           <BookingConfirmation 
 281 │             appointment={bookingResult.appointment}
 282 │             timeSlot={selectedTimeSlot}
 283 │             onDone={resetBooking}
 284 │           />
 285 │         )}
 286 │       </div>
 287 │     </div>
 288 │   );
 289 │ }
 290 │ import { useState } from "react";
     ·          ────┬───
     ·              ╰── `useState` redefined here
 291 │ import { Navbar } from "@/components/ui/Navbar";
 292 │ import { useLanguage } from "@/hooks/useLanguage";
 293 │ import { DatePicker } from "@/components/booking/DatePicker";
     ╰────
  × the name `DatePicker` is defined multiple times
     ╭─[/home/runner/workspace/src/pages/Booking.tsx:2:1]
   1 │ import { useState, useEffect } from 'react';
   2 │ import { DatePicker } from '@/components/booking/DatePicker';
     ·          ─────┬────
     ·               ╰── previous definition of `DatePicker` here
   3 │ import { TimeSlotPicker } from '@/components/booking/TimeSlotPicker';
   4 │ import { BookingForm } from '@/components/booking/BookingForm';
   5 │ import { BookingConfirmation } from '@/components/booking/BookingConfirmation';
   6 │ import { Appointment, TimeSlot, BookingFormData } from '@/lib/types';
   7 │ import { generateTimeSlots } from '@/lib/date-utils';
   8 │ import { v4 as uuidv4 } from 'uuid';
   9 │ import { supabase } from '@/integrations/supabase/client';
  10 │ import { toast } from 'sonner';
  11 │ 
  12 │ enum BookingStep {
  13 │   SELECT_DATE,
  14 │   SELECT_TIME,
  15 │   FILL_FORM,
  16 │   CONFIRMATION
  17 │ }
  18 │ 
  19 │ export default function Booking() {
  20 │   const [currentStep, setCurrentStep] = useState<BookingStep>(BookingStep.SELECT_DATE);
  21 │   const [selectedDate, setSelectedDate] = useState<Date | undefined>(undefined);
  22 │   const [timeSlots, setTimeSlots] = useState<TimeSlot[]>([]);
  23 │   const [selectedTimeSlot, setSelectedTimeSlot] = useState<TimeSlot | null>(null);
  24 │   const [appointment, setAppointment] = useState<Appointment | null>(null);
  25 │   const [isSubmitting, setIsSubmitting] = useState(false);
  26 │   const [isLoading, setIsLoading] = useState(false);
  27 │   const [bookingResult, setBookingResult] = useState<{ success: boolean; appointment: any | null }>({ success: false, appointment: null });
  28 │ 
  29 │ 
  30 │   // Fetch time slots for the selected date
  31 │   useEffect(() => {
  32 │     if (!selectedDate) return;
  33 │ 
  34 │     const fetchTimeSlots = async () => {
  35 │       setIsLoading(true);
  36 │ 
  37 │       try {
  38 │         // Formatiere das Datum für Supabase (YYYY-MM-DD)
  39 │         const formattedDate = selectedDate.toISOString().split('T')[0];
  40 │ 
  41 │         // Prüfe, ob bereits Zeitfenster für diesen Tag existieren
  42 │         const { data: existingSlots, error: fetchError } = await supabase
  43 │           .from('time_slots')
  44 │           .select('*')
  45 │           .eq('date', formattedDate);
  46 │ 
  47 │         if (fetchError) throw fetchError;
  48 │ 
  49 │         // Wenn Zeitfenster existieren, verwende diese
  50 │         if (existingSlots && existingSlots.length > 0) {
  51 │           const mappedSlots = existingSlots.map(slot => ({
  52 │             id: slot.id,
  53 │             date: slot.date,
  54 │             startTime: slot.start_time,
  55 │             endTime: slot.end_time,
  56 │             isAvailable: !slot.is_booked
  57 │           }));
  58 │ 
  59 │           setTimeSlots(mappedSlots);
  60 │         } else {
  61 │           // Generiere neue Zeitfenster und speichere sie in Supabase
  62 │           const generatedSlots = generateTimeSlots(selectedDate);
  63 │ 
  64 │           // Speichere die Slots in Supabase
  65 │           const { data: savedSlots, error: insertError } = await supabase
  66 │             .from('time_slots')
  67 │             .insert(
  68 │               generatedSlots.map(slot => ({
  69 │                 date: formattedDate,
  70 │                 start_time: slot.startTime,
  71 │                 end_time: slot.endTime,
  72 │                 is_booked: false
  73 │               }))
  74 │             )
  75 │             .select();
  76 │ 
  77 │           if (insertError) throw insertError;
  78 │ 
  79 │           if (savedSlots) {
  80 │             // Mappe die gespeicherten Slots zum Frontend-Format
  81 │             const mappedSlots = savedSlots.map(slot => ({
  82 │               id: slot.id,
  83 │               date: slot.date,
  84 │               startTime: slot.start_time,
  85 │               endTime: slot.end_time,
  86 │               isAvailable: !slot.is_booked
  87 │             }));
  88 │ 
  89 │             setTimeSlots(mappedSlots);
  90 │           }
  91 │         }
  92 │ 
  93 │         setCurrentStep(BookingStep.SELECT_TIME);
  94 │       } catch (error) {
  95 │         console.error('Error fetching/creating time slots:', error);
  96 │         toast.error('Fehler beim Laden der Verfügbarkeiten');
  97 │       } finally {
  98 │         setIsLoading(false);
  99 │       }
 100 │     };
 101 │ 
 102 │     fetchTimeSlots();
 103 │   }, [selectedDate]);
 104 │ 
 105 │   const handleDateSelect = (date: Date | undefined) => {
 106 │     setSelectedDate(date);
 107 │   };
 108 │ 
 109 │   const handleTimeSlotSelect = (timeSlot: TimeSlot) => {
 110 │     setSelectedTimeSlot(timeSlot);
 111 │     setCurrentStep(BookingStep.FILL_FORM);
 112 │   };
 113 │ 
 114 │   const handleFormSubmit = async (formData: BookingFormData) => {
 115 │     setIsSubmitting(true);
 116 │ 
 117 │     try {
 118 │       console.log('Submitting booking with time slot ID:', selectedTimeSlot?.id);
 119 │ 
 120 │       if (!selectedTimeSlot?.id) {
 121 │         throw new Error('Kein Zeitfenster ausgewählt');
 122 │       }
 123 │ 
 124 │       // Prüfen, ob der Zeitslot tatsächlich existiert
 125 │       const { data: slotExists, error: slotCheckError } = await supabase
 126 │         .from('time_slots')
 127 │         .select('id')
 128 │         .eq('id', selectedTimeSlot.id)
 129 │         .single();
 130 │ 
 131 │       if (slotCheckError || !slotExists) {
 132 │         console.error('Time slot check error:', slotCheckError);
 133 │         throw new Error(`Das gewählte Zeitfenster existiert nicht in der Datenbank: ${JSON.stringify(slotCheckError || 'No data')}`);
 134 │       }
 135 │ 
 136 │       // Create appointment record in Supabase
 137 │       const { data, error } = await supabase
 138 │         .from('appointments')
 139 │         .insert({
 140 │           time_slot_id: selectedTimeSlot.id,
 141 │           name: formData.name,
 142 │           email: formData.email,
 143 │           phone: formData.phone,
 144 │           notes: formData.notes || null,  // Explizit null setzen wenn leer
 145 │         })
 146 │         .select()
 147 │         .single();
 148 │ 
 149 │       if (error) {
 150 │         console.error('Appointment creation error:', error);
 151 │         throw new Error(`Error creating appointment: ${JSON.stringify(error)}`);
 152 │       }
 153 │ 
 154 │       // Update time slot to mark as booked
 155 │       const { error: updateError } = await supabase
 156 │         .from('time_slots')
 157 │         .update({ is_booked: true })
 158 │         .eq('id', selectedTimeSlot.id);
 159 │ 
 160 │       if (updateError) {
 161 │         console.error('Time slot update error:', updateError);
 162 │         throw new Error(`Error updating time slot: ${JSON.stringify(updateError)}`);
 163 │       }
 164 │ 
 165 │       // E-Mail-Bestätigung senden
 166 │       try {
 167 │         import('@/lib/email-utils').then(({ sendConfirmationEmail }) => {
 168 │           sendConfirmationEmail(data[0], selectedTimeSlot).then(() => {
 169 │             console.log('Bestätigungs-E-Mail gesendet');
 170 │           }).catch((emailError) => {
 171 │             console.error('Fehler beim Senden der Bestätigungs-E-Mail:', emailError);
 172 │             // Buchung wird trotzdem fortgesetzt, auch wenn E-Mail fehlschlägt
 173 │           });
 174 │         });
 175 │       } catch (emailError) {
 176 │         console.error('Fehler beim Senden der Bestätigungs-E-Mail:', emailError);
 177 │         // Buchung wird trotzdem fortgesetzt, auch wenn E-Mail fehlschlägt
 178 │       }
 179 │ 
 180 │       setBookingResult({
 181 │         success: true,
 182 │         appointment: data,
 183 │       });
 184 │ 
 185 │       setCurrentStep(BookingStep.CONFIRMATION);
 186 │     } catch (error: any) {
 187 │       console.error('Error creating appointment:', error);
 188 │       toast.error('Fehler bei der Terminbuchung: ' + (error.message || 'Unbekannter Fehler'));
 189 │     } finally {
 190 │       setIsLoading(false);
 191 │     }
 192 │   };
 193 │ 
 194 │   const resetBooking = () => {
 195 │     setCurrentStep(BookingStep.SELECT_DATE);
 196 │     setSelectedDate(undefined);
 197 │     setTimeSlots([]);
 198 │     setSelectedTimeSlot(null);
 199 │     setAppointment(null);
 200 │     setIsSubmitting(false);
 201 │     setIsLoading(false);
 202 │     setBookingResult({ success: false, appointment: null });
 203 │   };
 204 │ 
 205 │   return (
 206 │     <div className="container mx-auto px-4 py-12">
 207 │       <div className="max-w-3xl mx-auto">
 208 │         <div className="text-center mb-10">
 209 │           <h1 className="text-3xl font-bold mb-4">Termin buchen</h1>
 210 │           <p className="text-muted-foreground">
 211 │             Wählen Sie einen passenden Termin für Ihre persönliche Beratung oder Therapie.
 212 │           </p>
 213 │         </div>
 214 │ 
 215 │         <div className="mb-8">
 216 │           <div className="flex justify-between items-center mb-6">
 217 │             <div className="flex space-x-2">
 218 │               {[...Array(3)].map((_, i) => (
 219 │                 <div
 220 │                   key={i}
 221 │                   className={`w-8 h-8 rounded-full flex items-center justify-center ${
 222 │                     i < currentStep ? 'bg-primary text-primary-foreground' : 
 223 │                     i === currentStep ? 'bg-primary/20 text-primary border border-primary' : 
 224 │                     'bg-muted text-muted-foreground'
 225 │                   }`}
 226 │                 >
 227 │                   {i + 1}
 228 │                 </div>
 229 │               ))}
 230 │             </div>
 231 │ 
 232 │             <span className="text-sm text-muted-foreground">
 233 │               Schritt {currentStep + 1} von {Object.keys(BookingStep).length / 2}
 234 │             </span>
 235 │           </div>
 236 │         </div>
 237 │ 
 238 │         {currentStep === BookingStep.SELECT_DATE && (
 239 │           <DatePicker onDateSelect={handleDateSelect} />
 240 │         )}
 241 │ 
 242 │         {currentStep === BookingStep.SELECT_TIME && (
 243 │           <>
 244 │             <button
 245 │               onClick={() => setCurrentStep(BookingStep.SELECT_DATE)}
 246 │               className="mb-4 text-sm text-primary flex items-center"
 247 │             >
 248 │               ← Zurück zur Datumsauswahl
 249 │             </button>
 250 │ 
 251 │             {isLoading ? (
 252 │               <div className="text-center py-8">Lade Verfügbarkeiten...</div>
 253 │             ) : (
 254 │               <TimeSlotPicker 
 255 │                 timeSlots={timeSlots} 
 256 │                 onTimeSlotSelect={handleTimeSlotSelect} 
 257 │               />
 258 │             )}
 259 │           </>
 260 │         )}
 261 │ 
 262 │         {currentStep === BookingStep.FILL_FORM && selectedTimeSlot && (
 263 │           <>
 264 │             <button
 265 │               onClick={() => setCurrentStep(BookingStep.SELECT_TIME)}
 266 │               className="mb-4 text-sm text-primary flex items-center"
 267 │             >
 268 │               ← Zurück zur Zeitauswahl
 269 │             </button>
 270 │ 
 271 │             <BookingForm 
 272 │               selectedTimeSlot={selectedTimeSlot}
 273 │               onSubmit={handleFormSubmit}
 274 │               isSubmitting={isSubmitting}
 275 │             />
 276 │           </>
 277 │         )}
 278 │ 
 279 │         {currentStep === BookingStep.CONFIRMATION && bookingResult.success && bookingResult.appointment && selectedTimeSlot && (
 280 │           <BookingConfirmation 
 281 │             appointment={bookingResult.appointment}
 282 │             timeSlot={selectedTimeSlot}
 283 │             onDone={resetBooking}
 284 │           />
 285 │         )}
 286 │       </div>
 287 │     </div>
 288 │   );
 289 │ }
 290 │ import { useState } from "react";
 291 │ import { Navbar } from "@/components/ui/Navbar";
 292 │ import { useLanguage } from "@/hooks/useLanguage";
 293 │ import { DatePicker } from "@/components/booking/DatePicker";
     ·          ─────┬────
     ·               ╰── `DatePicker` redefined here
 294 │ import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
 295 │ import { Button } from "@/components/ui/button";
 296 │ import { Input } from "@/components/ui/input";
     ╰────
  × the name `Booking` is defined multiple times
     ╭─[/home/runner/workspace/src/pages/Booking.tsx:19:1]
  16 │   CONFIRMATION
  17 │ }
  18 │ 
  19 │ export default function Booking() {
     ·                         ───┬───
     ·                            ╰── previous definition of `Booking` here
  20 │   const [currentStep, setCurrentStep] = useState<BookingStep>(BookingStep.SELECT_DATE);
  21 │   const [selectedDate, setSelectedDate] = useState<Date | undefined>(undefined);
  22 │   const [timeSlots, setTimeSlots] = useState<TimeSlot[]>([]);
  23 │   const [selectedTimeSlot, setSelectedTimeSlot] = useState<TimeSlot | null>(null);
  24 │   const [appointment, setAppointment] = useState<Appointment | null>(null);
  25 │   const [isSubmitting, setIsSubmitting] = useState(false);
  26 │   const [isLoading, setIsLoading] = useState(false);
  27 │   const [bookingResult, setBookingResult] = useState<{ success: boolean; appointment: any | null }>({ success: false, appointment: null });
  28 │ 
  29 │ 
  30 │   // Fetch time slots for the selected date
  31 │   useEffect(() => {
  32 │     if (!selectedDate) return;
  33 │ 
  34 │     const fetchTimeSlots = async () => {
  35 │       setIsLoading(true);
  36 │ 
  37 │       try {
  38 │         // Formatiere das Datum für Supabase (YYYY-MM-DD)
  39 │         const formattedDate = selectedDate.toISOString().split('T')[0];
  40 │ 
  41 │         // Prüfe, ob bereits Zeitfenster für diesen Tag existieren
  42 │         const { data: existingSlots, error: fetchError } = await supabase
  43 │           .from('time_slots')
  44 │           .select('*')
  45 │           .eq('date', formattedDate);
  46 │ 
  47 │         if (fetchError) throw fetchError;
  48 │ 
  49 │         // Wenn Zeitfenster existieren, verwende diese
  50 │         if (existingSlots && existingSlots.length > 0) {
  51 │           const mappedSlots = existingSlots.map(slot => ({
  52 │             id: slot.id,
  53 │             date: slot.date,
  54 │             startTime: slot.start_time,
  55 │             endTime: slot.end_time,
  56 │             isAvailable: !slot.is_booked
  57 │           }));
  58 │ 
  59 │           setTimeSlots(mappedSlots);
  60 │         } else {
  61 │           // Generiere neue Zeitfenster und speichere sie in Supabase
  62 │           const generatedSlots = generateTimeSlots(selectedDate);
  63 │ 
  64 │           // Speichere die Slots in Supabase
  65 │           const { data: savedSlots, error: insertError } = await supabase
  66 │             .from('time_slots')
  67 │             .insert(
  68 │               generatedSlots.map(slot => ({
  69 │                 date: formattedDate,
  70 │                 start_time: slot.startTime,
  71 │                 end_time: slot.endTime,
  72 │                 is_booked: false
  73 │               }))
  74 │             )
  75 │             .select();
  76 │ 
  77 │           if (insertError) throw insertError;
  78 │ 
  79 │           if (savedSlots) {
  80 │             // Mappe die gespeicherten Slots zum Frontend-Format
  81 │             const mappedSlots = savedSlots.map(slot => ({
  82 │               id: slot.id,
  83 │               date: slot.date,
  84 │               startTime: slot.start_time,
  85 │               endTime: slot.end_time,
  86 │               isAvailable: !slot.is_booked
  87 │             }));
  88 │ 
  89 │             setTimeSlots(mappedSlots);
  90 │           }
  91 │         }
  92 │ 
  93 │         setCurrentStep(BookingStep.SELECT_TIME);
  94 │       } catch (error) {
  95 │         console.error('Error fetching/creating time slots:', error);
  96 │         toast.error('Fehler beim Laden der Verfügbarkeiten');
  97 │       } finally {
  98 │         setIsLoading(false);
  99 │       }
 100 │     };
 101 │ 
 102 │     fetchTimeSlots();
 103 │   }, [selectedDate]);
 104 │ 
 105 │   const handleDateSelect = (date: Date | undefined) => {
 106 │     setSelectedDate(date);
 107 │   };
 108 │ 
 109 │   const handleTimeSlotSelect = (timeSlot: TimeSlot) => {
 110 │     setSelectedTimeSlot(timeSlot);
 111 │     setCurrentStep(BookingStep.FILL_FORM);
 112 │   };
 113 │ 
 114 │   const handleFormSubmit = async (formData: BookingFormData) => {
 115 │     setIsSubmitting(true);
 116 │ 
 117 │     try {
 118 │       console.log('Submitting booking with time slot ID:', selectedTimeSlot?.id);
 119 │ 
 120 │       if (!selectedTimeSlot?.id) {
 121 │         throw new Error('Kein Zeitfenster ausgewählt');
 122 │       }
 123 │ 
 124 │       // Prüfen, ob der Zeitslot tatsächlich existiert
 125 │       const { data: slotExists, error: slotCheckError } = await supabase
 126 │         .from('time_slots')
 127 │         .select('id')
 128 │         .eq('id', selectedTimeSlot.id)
 129 │         .single();
 130 │ 
 131 │       if (slotCheckError || !slotExists) {
 132 │         console.error('Time slot check error:', slotCheckError);
 133 │         throw new Error(`Das gewählte Zeitfenster existiert nicht in der Datenbank: ${JSON.stringify(slotCheckError || 'No data')}`);
 134 │       }
 135 │ 
 136 │       // Create appointment record in Supabase
 137 │       const { data, error } = await supabase
 138 │         .from('appointments')
 139 │         .insert({
 140 │           time_slot_id: selectedTimeSlot.id,
 141 │           name: formData.name,
 142 │           email: formData.email,
 143 │           phone: formData.phone,
 144 │           notes: formData.notes || null,  // Explizit null setzen wenn leer
 145 │         })
 146 │         .select()
 147 │         .single();
 148 │ 
 149 │       if (error) {
 150 │         console.error('Appointment creation error:', error);
 151 │         throw new Error(`Error creating appointment: ${JSON.stringify(error)}`);
 152 │       }
 153 │ 
 154 │       // Update time slot to mark as booked
 155 │       const { error: updateError } = await supabase
 156 │         .from('time_slots')
 157 │         .update({ is_booked: true })
 158 │         .eq('id', selectedTimeSlot.id);
 159 │ 
 160 │       if (updateError) {
 161 │         console.error('Time slot update error:', updateError);
 162 │         throw new Error(`Error updating time slot: ${JSON.stringify(updateError)}`);
 163 │       }
 164 │ 
 165 │       // E-Mail-Bestätigung senden
 166 │       try {
 167 │         import('@/lib/email-utils').then(({ sendConfirmationEmail }) => {
 168 │           sendConfirmationEmail(data[0], selectedTimeSlot).then(() => {
 169 │             console.log('Bestätigungs-E-Mail gesendet');
 170 │           }).catch((emailError) => {
 171 │             console.error('Fehler beim Senden der Bestätigungs-E-Mail:', emailError);
 172 │             // Buchung wird trotzdem fortgesetzt, auch wenn E-Mail fehlschlägt
 173 │           });
 174 │         });
 175 │       } catch (emailError) {
 176 │         console.error('Fehler beim Senden der Bestätigungs-E-Mail:', emailError);
 177 │         // Buchung wird trotzdem fortgesetzt, auch wenn E-Mail fehlschlägt
 178 │       }
 179 │ 
 180 │       setBookingResult({
 181 │         success: true,
 182 │         appointment: data,
 183 │       });
 184 │ 
 185 │       setCurrentStep(BookingStep.CONFIRMATION);
 186 │     } catch (error: any) {
 187 │       console.error('Error creating appointment:', error);
 188 │       toast.error('Fehler bei der Terminbuchung: ' + (error.message || 'Unbekannter Fehler'));
 189 │     } finally {
 190 │       setIsLoading(false);
 191 │     }
 192 │   };
 193 │ 
 194 │   const resetBooking = () => {
 195 │     setCurrentStep(BookingStep.SELECT_DATE);
 196 │     setSelectedDate(undefined);
 197 │     setTimeSlots([]);
 198 │     setSelectedTimeSlot(null);
 199 │     setAppointment(null);
 200 │     setIsSubmitting(false);
 201 │     setIsLoading(false);
 202 │     setBookingResult({ success: false, appointment: null });
 203 │   };
 204 │ 
 205 │   return (
 206 │     <div className="container mx-auto px-4 py-12">
 207 │       <div className="max-w-3xl mx-auto">
 208 │         <div className="text-center mb-10">
 209 │           <h1 className="text-3xl font-bold mb-4">Termin buchen</h1>
 210 │           <p className="text-muted-foreground">
 211 │             Wählen Sie einen passenden Termin für Ihre persönliche Beratung oder Therapie.
 212 │           </p>
 213 │         </div>
 214 │ 
 215 │         <div className="mb-8">
 216 │           <div className="flex justify-between items-center mb-6">
 217 │             <div className="flex space-x-2">
 218 │               {[...Array(3)].map((_, i) => (
 219 │                 <div
 220 │                   key={i}
 221 │                   className={`w-8 h-8 rounded-full flex items-center justify-center ${
 222 │                     i < currentStep ? 'bg-primary text-primary-foreground' : 
 223 │                     i === currentStep ? 'bg-primary/20 text-primary border border-primary' : 
 224 │                     'bg-muted text-muted-foreground'
 225 │                   }`}
 226 │                 >
 227 │                   {i + 1}
 228 │                 </div>
 229 │               ))}
 230 │             </div>
 231 │ 
 232 │             <span className="text-sm text-muted-foreground">
 233 │               Schritt {currentStep + 1} von {Object.keys(BookingStep).length / 2}
 234 │             </span>
 235 │           </div>
 236 │         </div>
 237 │ 
 238 │         {currentStep === BookingStep.SELECT_DATE && (
 239 │           <DatePicker onDateSelect={handleDateSelect} />
 240 │         )}
 241 │ 
 242 │         {currentStep === BookingStep.SELECT_TIME && (
 243 │           <>
 244 │             <button
 245 │               onClick={() => setCurrentStep(BookingStep.SELECT_DATE)}
 246 │               className="mb-4 text-sm text-primary flex items-center"
 247 │             >
 248 │               ← Zurück zur Datumsauswahl
 249 │             </button>
 250 │ 
 251 │             {isLoading ? (
 252 │               <div className="text-center py-8">Lade Verfügbarkeiten...</div>
 253 │             ) : (
 254 │               <TimeSlotPicker 
 255 │                 timeSlots={timeSlots} 
 256 │                 onTimeSlotSelect={handleTimeSlotSelect} 
 257 │               />
 258 │             )}
 259 │           </>
 260 │         )}
 261 │ 
 262 │         {currentStep === BookingStep.FILL_FORM && selectedTimeSlot && (
 263 │           <>
 264 │             <button
 265 │               onClick={() => setCurrentStep(BookingStep.SELECT_TIME)}
 266 │               className="mb-4 text-sm text-primary flex items-center"
 267 │             >
 268 │               ← Zurück zur Zeitauswahl
 269 │             </button>
 270 │ 
 271 │             <BookingForm 
 272 │               selectedTimeSlot={selectedTimeSlot}
 273 │               onSubmit={handleFormSubmit}
 274 │               isSubmitting={isSubmitting}
 275 │             />
 276 │           </>
 277 │         )}
 278 │ 
 279 │         {currentStep === BookingStep.CONFIRMATION && bookingResult.success && bookingResult.appointment && selectedTimeSlot && (
 280 │           <BookingConfirmation 
 281 │             appointment={bookingResult.appointment}
 282 │             timeSlot={selectedTimeSlot}
 283 │             onDone={resetBooking}
 284 │           />
 285 │         )}
 286 │       </div>
 287 │     </div>
 288 │   );
 289 │ }
 290 │ import { useState } from "react";
 291 │ import { Navbar } from "@/components/ui/Navbar";
 292 │ import { useLanguage } from "@/hooks/useLanguage";
 293 │ import { DatePicker } from "@/components/booking/DatePicker";
 294 │ import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
 295 │ import { Button } from "@/components/ui/button";
 296 │ import { Input } from "@/components/ui/input";
 297 │ import { Textarea } from "@/components/ui/textarea";
 298 │ import { Label } from "@/components/ui/label";
 299 │ 
 300 │ export default function Booking() {
     ·                         ───┬───
     ·                            ╰── `Booking` redefined here
 301 │   const { t, dir } = useLanguage();
 302 │   const [selectedDate, setSelectedDate] = useState<Date | undefined>(undefined);
 303 │   const [selectedTimeSlot, setSelectedTimeSlot] = useState<string | null>(null);
     ╰────
  × the name `default` is exported multiple times
     ╭─[/home/runner/workspace/src/pages/Booking.tsx:19:1]
  16 │       CONFIRMATION
  17 │     }
  18 │     
  19 │ ╭─▶ export default function Booking() {
  20 │ │     const [currentStep, setCurrentStep] = useState<BookingStep>(BookingStep.SELECT_DATE);
  21 │ │     const [selectedDate, setSelectedDate] = useState<Date | undefined>(undefined);
  22 │ │     const [timeSlots, setTimeSlots] = useState<TimeSlot[]>([]);
  23 │ │     const [selectedTimeSlot, setSelectedTimeSlot] = useState<TimeSlot | null>(null);
  24 │ │     const [appointment, setAppointment] = useState<Appointment | null>(null);
  25 │ │     const [isSubmitting, setIsSubmitting] = useState(false);
  26 │ │     const [isLoading, setIsLoading] = useState(false);
  27 │ │     const [bookingResult, setBookingResult] = useState<{ success: boolean; appointment: any | null }>({ success: false, appointment: null });
  28 │ │   
  29 │ │   
  30 │ │     // Fetch time slots for the selected date
  31 │ │     useEffect(() => {
  32 │ │       if (!selectedDate) return;
  33 │ │   
  34 │ │       const fetchTimeSlots = async () => {
  35 │ │         setIsLoading(true);
  36 │ │   
  37 │ │         try {
  38 │ │           // Formatiere das Datum für Supabase (YYYY-MM-DD)
  39 │ │           const formattedDate = selectedDate.toISOString().split('T')[0];
  40 │ │   
  41 │ │           // Prüfe, ob bereits Zeitfenster für diesen Tag existieren
  42 │ │           const { data: existingSlots, error: fetchError } = await supabase
  43 │ │             .from('time_slots')
  44 │ │             .select('*')
  45 │ │             .eq('date', formattedDate);
  46 │ │   
  47 │ │           if (fetchError) throw fetchError;
  48 │ │   
  49 │ │           // Wenn Zeitfenster existieren, verwende diese
  50 │ │           if (existingSlots && existingSlots.length > 0) {
  51 │ │             const mappedSlots = existingSlots.map(slot => ({
  52 │ │               id: slot.id,
  53 │ │               date: slot.date,
  54 │ │               startTime: slot.start_time,
  55 │ │               endTime: slot.end_time,
  56 │ │               isAvailable: !slot.is_booked
  57 │ │             }));
  58 │ │   
  59 │ │             setTimeSlots(mappedSlots);
  60 │ │           } else {
  61 │ │             // Generiere neue Zeitfenster und speichere sie in Supabase
  62 │ │             const generatedSlots = generateTimeSlots(selectedDate);
  63 │ │   
  64 │ │             // Speichere die Slots in Supabase
  65 │ │             const { data: savedSlots, error: insertError } = await supabase
  66 │ │               .from('time_slots')
  67 │ │               .insert(
  68 │ │                 generatedSlots.map(slot => ({
  69 │ │                   date: formattedDate,
  70 │ │                   start_time: slot.startTime,
  71 │ │                   end_time: slot.endTime,
  72 │ │                   is_booked: false
  73 │ │                 }))
  74 │ │               )
  75 │ │               .select();
  76 │ │   
  77 │ │             if (insertError) throw insertError;
  78 │ │   
  79 │ │             if (savedSlots) {
  80 │ │               // Mappe die gespeicherten Slots zum Frontend-Format
  81 │ │               const mappedSlots = savedSlots.map(slot => ({
  82 │ │                 id: slot.id,
  83 │ │                 date: slot.date,
  84 │ │                 startTime: slot.start_time,
  85 │ │                 endTime: slot.end_time,
  86 │ │                 isAvailable: !slot.is_booked
  87 │ │               }));
  88 │ │   
  89 │ │               setTimeSlots(mappedSlots);
  90 │ │             }
  91 │ │           }
  92 │ │   
  93 │ │           setCurrentStep(BookingStep.SELECT_TIME);
  94 │ │         } catch (error) {
  95 │ │           console.error('Error fetching/creating time slots:', error);
  96 │ │           toast.error('Fehler beim Laden der Verfügbarkeiten');
  97 │ │         } finally {
  98 │ │           setIsLoading(false);
  99 │ │         }
 100 │ │       };
 101 │ │   
 102 │ │       fetchTimeSlots();
 103 │ │     }, [selectedDate]);
 104 │ │   
 105 │ │     const handleDateSelect = (date: Date | undefined) => {
 106 │ │       setSelectedDate(date);
 107 │ │     };
 108 │ │   
 109 │ │     const handleTimeSlotSelect = (timeSlot: TimeSlot) => {
 110 │ │       setSelectedTimeSlot(timeSlot);
 111 │ │       setCurrentStep(BookingStep.FILL_FORM);
 112 │ │     };
 113 │ │   
 114 │ │     const handleFormSubmit = async (formData: BookingFormData) => {
 115 │ │       setIsSubmitting(true);
 116 │ │   
 117 │ │       try {
 118 │ │         console.log('Submitting booking with time slot ID:', selectedTimeSlot?.id);
 119 │ │   
 120 │ │         if (!selectedTimeSlot?.id) {
 121 │ │           throw new Error('Kein Zeitfenster ausgewählt');
 122 │ │         }
 123 │ │   
 124 │ │         // Prüfen, ob der Zeitslot tatsächlich existiert
 125 │ │         const { data: slotExists, error: slotCheckError } = await supabase
 126 │ │           .from('time_slots')
 127 │ │           .select('id')
 128 │ │           .eq('id', selectedTimeSlot.id)
 129 │ │           .single();
 130 │ │   
 131 │ │         if (slotCheckError || !slotExists) {
 132 │ │           console.error('Time slot check error:', slotCheckError);
 133 │ │           throw new Error(`Das gewählte Zeitfenster existiert nicht in der Datenbank: ${JSON.stringify(slotCheckError || 'No data')}`);
 134 │ │         }
 135 │ │   
 136 │ │         // Create appointment record in Supabase
 137 │ │         const { data, error } = await supabase
 138 │ │           .from('appointments')
 139 │ │           .insert({
 140 │ │             time_slot_id: selectedTimeSlot.id,
 141 │ │             name: formData.name,
 142 │ │             email: formData.email,
 143 │ │             phone: formData.phone,
 144 │ │             notes: formData.notes || null,  // Explizit null setzen wenn leer
 145 │ │           })
 146 │ │           .select()
 147 │ │           .single();
 148 │ │   
 149 │ │         if (error) {
 150 │ │           console.error('Appointment creation error:', error);
 151 │ │           throw new Error(`Error creating appointment: ${JSON.stringify(error)}`);
 152 │ │         }
 153 │ │   
 154 │ │         // Update time slot to mark as booked
 155 │ │         const { error: updateError } = await supabase
 156 │ │           .from('time_slots')
 157 │ │           .update({ is_booked: true })
 158 │ │           .eq('id', selectedTimeSlot.id);
 159 │ │   
 160 │ │         if (updateError) {
 161 │ │           console.error('Time slot update error:', updateError);
 162 │ │           throw new Error(`Error updating time slot: ${JSON.stringify(updateError)}`);
 163 │ │         }
 164 │ │   
 165 │ │         // E-Mail-Bestätigung senden
 166 │ │         try {
 167 │ │           import('@/lib/email-utils').then(({ sendConfirmationEmail }) => {
 168 │ │             sendConfirmationEmail(data[0], selectedTimeSlot).then(() => {
 169 │ │               console.log('Bestätigungs-E-Mail gesendet');
 170 │ │             }).catch((emailError) => {
 171 │ │               console.error('Fehler beim Senden der Bestätigungs-E-Mail:', emailError);
 172 │ │               // Buchung wird trotzdem fortgesetzt, auch wenn E-Mail fehlschlägt
 173 │ │             });
 174 │ │           });
 175 │ │         } catch (emailError) {
 176 │ │           console.error('Fehler beim Senden der Bestätigungs-E-Mail:', emailError);
 177 │ │           // Buchung wird trotzdem fortgesetzt, auch wenn E-Mail fehlschlägt
 178 │ │         }
 179 │ │   
 180 │ │         setBookingResult({
 181 │ │           success: true,
 182 │ │           appointment: data,
 183 │ │         });
 184 │ │   
 185 │ │         setCurrentStep(BookingStep.CONFIRMATION);
 186 │ │       } catch (error: any) {
 187 │ │         console.error('Error creating appointment:', error);
 188 │ │         toast.error('Fehler bei der Terminbuchung: ' + (error.message || 'Unbekannter Fehler'));
 189 │ │       } finally {
 190 │ │         setIsLoading(false);
 191 │ │       }
 192 │ │     };
 193 │ │   
 194 │ │     const resetBooking = () => {
 195 │ │       setCurrentStep(BookingStep.SELECT_DATE);
 196 │ │       setSelectedDate(undefined);
 197 │ │       setTimeSlots([]);
 198 │ │       setSelectedTimeSlot(null);
 199 │ │       setAppointment(null);
 200 │ │       setIsSubmitting(false);
 201 │ │       setIsLoading(false);
 202 │ │       setBookingResult({ success: false, appointment: null });
 203 │ │     };
 204 │ │   
 205 │ │     return (
 206 │ │       <div className="container mx-auto px-4 py-12">
 207 │ │         <div className="max-w-3xl mx-auto">
 208 │ │           <div className="text-center mb-10">
 209 │ │             <h1 className="text-3xl font-bold mb-4">Termin buchen</h1>
 210 │ │             <p className="text-muted-foreground">
 211 │ │               Wählen Sie einen passenden Termin für Ihre persönliche Beratung oder Therapie.
 212 │ │             </p>
 213 │ │           </div>
 214 │ │   
 215 │ │           <div className="mb-8">
 216 │ │             <div className="flex justify-between items-center mb-6">
 217 │ │               <div className="flex space-x-2">
 218 │ │                 {[...Array(3)].map((_, i) => (
 219 │ │                   <div
 220 │ │                     key={i}
 221 │ │                     className={`w-8 h-8 rounded-full flex items-center justify-center ${
 222 │ │                       i < currentStep ? 'bg-primary text-primary-foreground' : 
 223 │ │                       i === currentStep ? 'bg-primary/20 text-primary border border-primary' : 
 224 │ │                       'bg-muted text-muted-foreground'
 225 │ │                     }`}
 226 │ │                   >
 227 │ │                     {i + 1}
 228 │ │                   </div>
 229 │ │                 ))}
 230 │ │               </div>
 231 │ │   
 232 │ │               <span className="text-sm text-muted-foreground">
 233 │ │                 Schritt {currentStep + 1} von {Object.keys(BookingStep).length / 2}
 234 │ │               </span>
 235 │ │             </div>
 236 │ │           </div>
 237 │ │   
 238 │ │           {currentStep === BookingStep.SELECT_DATE && (
 239 │ │             <DatePicker onDateSelect={handleDateSelect} />
 240 │ │           )}
 241 │ │   
 242 │ │           {currentStep === BookingStep.SELECT_TIME && (
 243 │ │             <>
 244 │ │               <button
 245 │ │                 onClick={() => setCurrentStep(BookingStep.SELECT_DATE)}
 246 │ │                 className="mb-4 text-sm text-primary flex items-center"
 247 │ │               >
 248 │ │                 ← Zurück zur Datumsauswahl
 249 │ │               </button>
 250 │ │   
 251 │ │               {isLoading ? (
 252 │ │                 <div className="text-center py-8">Lade Verfügbarkeiten...</div>
 253 │ │               ) : (
 254 │ │                 <TimeSlotPicker 
 255 │ │                   timeSlots={timeSlots} 
 256 │ │                   onTimeSlotSelect={handleTimeSlotSelect} 
 257 │ │                 />
 258 │ │               )}
 259 │ │             </>
 260 │ │           )}
 261 │ │   
 262 │ │           {currentStep === BookingStep.FILL_FORM && selectedTimeSlot && (
 263 │ │             <>
 264 │ │               <button
 265 │ │                 onClick={() => setCurrentStep(BookingStep.SELECT_TIME)}
 266 │ │                 className="mb-4 text-sm text-primary flex items-center"
 267 │ │               >
 268 │ │                 ← Zurück zur Zeitauswahl
 269 │ │               </button>
 270 │ │   
 271 │ │               <BookingForm 
 272 │ │                 selectedTimeSlot={selectedTimeSlot}
 273 │ │                 onSubmit={handleFormSubmit}
 274 │ │                 isSubmitting={isSubmitting}
 275 │ │               />
 276 │ │             </>
 277 │ │           )}
 278 │ │   
 279 │ │           {currentStep === BookingStep.CONFIRMATION && bookingResult.success && bookingResult.appointment && selectedTimeSlot && (
 280 │ │             <BookingConfirmation 
 281 │ │               appointment={bookingResult.appointment}
 282 │ │               timeSlot={selectedTimeSlot}
 283 │ │               onDone={resetBooking}
 284 │ │             />
 285 │ │           )}
 286 │ │         </div>
 287 │ │       </div>
 288 │ │     );
 289 │ ├─▶ }
     · ╰──── previous exported here
 290 │     import { useState } from "react";
 291 │     import { Navbar } from "@/components/ui/Navbar";
 292 │     import { useLanguage } from "@/hooks/useLanguage";
 293 │     import { DatePicker } from "@/components/booking/DatePicker";
 294 │     import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
 295 │     import { Button } from "@/components/ui/button";
 296 │     import { Input } from "@/components/ui/input";
 297 │     import { Textarea } from "@/components/ui/textarea";
 298 │     import { Label } from "@/components/ui/label";
 299 │     
 300 │ ╭─▶ export default function Booking() {
 301 │ │     const { t, dir } = useLanguage();
 302 │ │     const [selectedDate, setSelectedDate] = useState<Date | undefined>(undefined);
 303 │ │     const [selectedTimeSlot, setSelectedTimeSlot] = useState<string | null>(null);
 304 │ │     
 305 │ │     // Mock time slots - in a real app, you'd fetch these from your API
 306 │ │     const timeSlots = selectedDate ? ["09:00", "10:00", "11:00", "14:00", "15:00"] : [];
 307 │ │     
 308 │ │     return (
 309 │ │       <div className="min-h-screen" dir={dir}>
 310 │ │         <Navbar />
 311 │ │         <main className="container mx-auto p-4">
 312 │ │           <h1 className="text-3xl font-bold mb-6">{t('booking')}</h1>
 313 │ │           
 314 │ │           <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
 315 │ │             <Card>
 316 │ │               <CardHeader>
 317 │ │                 <CardTitle>{t('selectDate')}</CardTitle>
 318 │ │               </CardHeader>
 319 │ │               <CardContent>
 320 │ │                 <DatePicker onDateSelect={setSelectedDate} />
 321 │ │               </CardContent>
 322 │ │             </Card>
 323 │ │             
 324 │ │             <Card>
 325 │ │               <CardHeader>
 326 │ │                 <CardTitle>{t('selectTime')}</CardTitle>
 327 │ │               </CardHeader>
 328 │ │               <CardContent>
 329 │ │                 {selectedDate ? (
 330 │ │                   <>
 331 │ │                     <h3 className="mb-4">{t('availableTimeSlots')}</h3>
 332 │ │                     <div className="grid grid-cols-2 gap-2">
 333 │ │                       {timeSlots.map((time) => (
 334 │ │                         <Button
 335 │ │                           key={time}
 336 │ │                           variant={selectedTimeSlot === time ? "default" : "outline"}
 337 │ │                           onClick={() => setSelectedTimeSlot(time)}
 338 │ │                         >
 339 │ │                           {time}
 340 │ │                         </Button>
 341 │ │                       ))}
 342 │ │                     </div>
 343 │ │                   </>
 344 │ │                 ) : (
 345 │ │                   <p>{t('selectDate')}</p>
 346 │ │                 )}
 347 │ │                 {selectedDate && timeSlots.length === 0 && (
 348 │ │                   <p>{t('noTimeSlotsAvailable')}</p>
 349 │ │                 )}
 350 │ │               </CardContent>
 351 │ │             </Card>
 352 │ │           </div>
 353 │ │           
 354 │ │           {selectedTimeSlot && (
 355 │ │             <Card className="mt-6">
 356 │ │               <CardHeader>
 357 │ │                 <CardTitle>{t('personalInfo')}</CardTitle>
 358 │ │               </CardHeader>
 359 │ │               <CardContent>
 360 │ │                 <form className="space-y-4">
 361 │ │                   <div className="grid w-full items-center gap-1.5">
 362 │ │                     <Label htmlFor="name">{t('name')}</Label>
 363 │ │                     <Input id="name" placeholder={t('name')} />
 364 │ │                   </div>
 365 │ │                   
 366 │ │                   <div className="grid w-full items-center gap-1.5">
 367 │ │                     <Label htmlFor="email">{t('email')}</Label>
 368 │ │                     <Input id="email" type="email" placeholder={t('email')} />
 369 │ │                   </div>
 370 │ │                   
 371 │ │                   <div className="grid w-full items-center gap-1.5">
 372 │ │                     <Label htmlFor="phone">{t('phone')}</Label>
 373 │ │                     <Input id="phone" placeholder={t('phone')} />
 374 │ │                   </div>
 375 │ │                   
 376 │ │                   <div className="grid w-full items-center gap-1.5">
 377 │ │                     <Label htmlFor="notes">{t('notes')}</Label>
 378 │ │                     <Textarea id="notes" placeholder={t('notes')} />
 379 │ │                   </div>
 380 │ │                   
 381 │ │                   <div className="flex justify-end gap-2">
 382 │ │                     <Button variant="outline">{t('cancel')}</Button>
 383 │ │                     <Button>{t('submit')}</Button>
 384 │ │                   </div>
 385 │ │                 </form>
 386 │ │               </CardContent>
 387 │ │             </Card>
 388 │ │           )}
 389 │ │         </main>
 390 │ │       </div>
 391 │ │     );
 392 │ ├─▶ }
     · ╰──── exported more than once
     ╰────

Advice:   ☞ Exported identifiers must be unique
/home/runner/workspace/src/pages/Booking.tsx:1:1
1  |  import { useState, useEffect } from 'react';
   |   ^
2  |  import { DatePicker } from '@/components/booking/DatePicker';
3  |  import { TimeSlotPicker } from '@/components/booking/TimeSlotPicker';
Click outside, press Esc key, or fix the code to dismiss.
You can also disable this overlay by setting server.hmr.overlay to false in vite.config.ts.